## NestJS 애플리케이션에서의 동시성 처리

### 1. 동시성 문제란?

동시성 문제는 여러 스레드나 프로세스가 공유 자원에 동시에 접근할 때 발생하는 문제입니다.
웹 애플리케이션에서는 여러 사용자가 동시에 같은 데이터를 수정하려 할 때 데이터 무결성이 깨질 수 있습니다.

**일반적인 동시성 문제 시나리오:**

- 포인트 충전/차감 시 race condition
- 재고 관리 시 overselling 문제
- 좌석 예약 시 중복 예약 문제
- 카운터 증가 시 lost update 문제

### 2. 동시성 제어 방식별 장단점 비교

#### 2.1 애플리케이션 레벨 동시성 제어

| 방식                | 장점                                                                         | 단점                                                                        | 적용 시나리오                                             |
| ------------------- | ---------------------------------------------------------------------------- | --------------------------------------------------------------------------- | --------------------------------------------------------- |
| **Mutex**           | • 구현이 간단<br>• 데드락 위험 낮음<br>• 메모리 사용량 적음                  | • 단일 인스턴스에서만 동작<br>• 확장성 제한<br>• 프로세스 재시작 시 락 손실 | • 단일 서버 환경<br>• 간단한 임계 영역 보호               |
| **Semaphore**       | • 동시 처리량 제어 가능<br>• 리소스 풀 관리 효과적<br>• 처리량과 안정성 균형 | • 복잡한 구현<br>• 기아 상태 가능성<br>• 디버깅 어려움                      | • API 호출 제한<br>• 커넥션 풀 관리<br>• 동시 업로드 제한 |
| **Read-Write Lock** | • 읽기 성능 최적화<br>• 읽기 작업 병렬 처리<br>• Writer 우선순위 제어        | • 복잡한 상태 관리<br>• Writer 기아 가능성<br>• 메모리 오버헤드             | • 캐시 시스템<br>• 설정 데이터 관리<br>• 통계 데이터 처리 |
| **Queue 기반**      | • 순서 보장<br>• 백프레셔 제어<br>• 에러 처리 용이                           | • 지연 시간 증가<br>• 메모리 사용량 증가<br>• 처리량 제한                   | • 순차 처리 필요<br>• 배치 작업<br>• 이벤트 처리          |

#### 2.2 데이터베이스 레벨 동시성 제어

| 방식                    | 장점                                                                   | 단점                                                                       | 적용 시나리오                                               |
| ----------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------- | ----------------------------------------------------------- |
| **Optimistic Locking**  | • 높은 동시성<br>• 데드락 없음<br>• 성능 우수 (충돌 적을 때)           | • 충돌 시 재시도 필요<br>• 복잡한 에러 처리<br>• 높은 충돌률에서 성능 저하 | • 읽기 많은 시스템<br>• 충돌 빈도 낮음<br>• 웹 애플리케이션 |
| **Pessimistic Locking** | • 데이터 일관성 보장<br>• 충돌 시 대기만 하면 됨<br>• 예측 가능한 동작 | • 성능 저하<br>• 데드락 위험<br>• 확장성 제한                              | • 금융 거래<br>• 재고 관리<br>• 중요한 비즈니스 로직        |
| **MVCC**                | • 읽기 블로킹 없음<br>• 높은 동시성<br>• 일관된 읽기                   | • 롤백 세그먼트 관리<br>• 복잡한 구현<br>• 메모리 사용량 증가              | • 대부분의 RDBMS<br>• 분석 시스템<br>• 보고서 생성          |

#### 2.3 분산 환경 동시성 제어

| 방식                   | 장점                                                       | 단점                                                     | 적용 시나리오                                                |
| ---------------------- | ---------------------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| **Redis 분산 락**      | • 다중 인스턴스 지원<br>• TTL로 안전성 보장<br>• 빠른 성능 | • Redis 의존성<br>• 네트워크 지연 영향<br>• 복잡한 구현  | • 마이크로서비스<br>• 분산 배치 작업<br>• 글로벌 리소스 관리 |
| **Database 분산 락**   | • 트랜잭션과 일관성<br>• 별도 인프라 불필요<br>• ACID 보장 | • 데이터베이스 부하<br>• 성능 저하<br>• 확장성 제한      | • 단순한 분산 환경<br>• 기존 DB 활용<br>• 강한 일관성 필요   |
| **Consensus 알고리즘** | • 강한 일관성<br>• 장애 복구 능력<br>• 분산 합의           | • 복잡한 구현<br>• 높은 지연시간<br>• 네트워크 분할 취약 | • 분산 시스템 코디네이션<br>• 리더 선출<br>• 설정 관리       |

#### 2.4 성능 vs 안전성 트레이드오프

```
성능 ←─────────────────────────────────────────────────────→ 안전성

락x        Optimistic     Read-Write    Pessimistic    분산 락
(Race       Locking       Lock          Locking       (Redis/DB)
Condition)
   ↑                                                      ↑
  빠름                                                   안전
```

### 3. JS에서의 동시성 제어의 특수성

#### 3.1 Node.js의 싱글 스레드 모델

- Node.js는 싱글 스레드 이벤트 루프 기반으로 동작합니다.
- 모든 JS 코드는 하나의 스레드에서 실행되지만, I/O 작업(네트워크, 파일 등)은 libuv의 워커 스레드에서 비동기적으로 처리됩니다.
- 이 구조 덕분에 race condition이 적을 것 같지만, 실제로는 여러 요청이 동시에 처리되는 상황에서 공유 자원(메모리, DB 등)에 대한 동시성 문제가 발생할 수 있습니다.

#### 3.2 JS 환경에서의 동시성 문제

- Node.js 프로세스는 싱글 스레드이지만, 여러 사용자의 요청이 논리적으로 "동시에" 처리됩니다.
- 예를 들어, 한 사용자가 포인트를 충전하는 동안 다른 사용자가 동시에 포인트를 차감하면, 두 요청이 거의 동시에 같은 데이터를 읽고 쓸 수 있습니다.
- 특히, DB, 캐시(Redis), 파일 등 외부 자원에 접근할 때 race condition이 발생할 수 있습니다.

#### 3.3 Mutex 등 동시성 제어 기법의 적용

- JS에는 언어 차원의 Mutex(뮤텍스)나 Lock이 내장되어 있지 않습니다.
- 하지만, 여러 요청이 동일한 자원에 접근할 때 임계 구역(critical section)을 보호하기 위해 "뮤텍스 패턴"을 구현할 수 있습니다.
- 대표적인 방법:
  - **메모리 기반 Mutex**: 단일 Node.js 인스턴스에서만 동작. 예: npm 패키지 async-mutex, await-lock 등.
  - **분산 Mutex**: 여러 인스턴스/프로세스 환경에서는 Redis 등 외부 시스템을 활용한 분산 락(Redis Redlock 등)이 필요.

- 메모리 기반 Mutex는 단일 인스턴스에서만 안전합니다. (서버가 여러 대면 효과 없음)
- 분산 락은 네트워크 지연, 장애, 락 해제 실패 등 다양한 이슈에 주의해야 합니다.
- 락을 잘못 사용하면 데드락(Deadlock), 성능 저하, 락 손실 등 부작용이 발생할 수 있습니다.

- Mutex가 필요한 대표적 상황:
  - 포인트 충전/차감 등 "동일 사용자의 포인트"를 동시에 변경할 수 있는 경우
  - 재고 감소, 좌석 예약 등 "동일 자원"에 대한 동시 접근이 빈번한 경우
  - 순차적 처리가 반드시 필요한 비즈니스 로직

##### 예시: async-mutex를 활용한 임계 구역 보호

```typescript
import { Mutex } from 'async-mutex';

const mutex = new Mutex();

async function criticalSection() {
  const release = await mutex.acquire();
  try {
    // 임계 구역: 공유 자원 접근/수정
  } finally {
    release();
  }
}
```

---

이처럼 Node.js 환경에서도 동시성 문제는 충분히 발생할 수 있으며, 상황에 맞는 동시성 제어 기법을 선택하는 것이 중요합니다. 단일 인스턴스에서는 메모리 기반 Mutex, 분산 환경에서는 Redis 등 외부 시스템을 활용한 분산 락을 적절히 활용해야 합니다.
